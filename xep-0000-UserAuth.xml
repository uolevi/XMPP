<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE xep SYSTEM 'xep.dtd' [
  <!ENTITY % ents SYSTEM 'xep.ent'>
  <!ENTITY rfc4226 "<span class='ref'><link url='http://tools.ietf.org/html/rfc4226'>RFC 4226</link></span> <note>RFC 4226: HOTP: An HMAC-Based One-Time Password Algorithm &lt;<link url='http://tools.ietf.org/html/rfc4226'>http://tools.ietf.org/html/rfc4226</link>&gt;.</note>" >
  <!ENTITY rfc6238 "<span class='ref'><link url='http://tools.ietf.org/html/rfc6238'>RFC 6238</link></span> <note>RFC 6238: TOTP: Time-Based One-Time Password Algorithm &lt;<link url='http://tools.ietf.org/html/rfc6238'>http://tools.ietf.org/html/rfc6238</link>&gt;.</note>" >

%ents;
]>
<?xml-stylesheet type='text/xsl' href='xep.xsl'?>
<xep>
<header>
 
  <title>Transmitting authentication factor information using Ad-Hoc Commands</title>
 
  <abstract>This document specifies how to use Ad-Hoc Commands to transmit 
  information used in two-factor authentication. 
  </abstract>
  
  <legal>
    <copyright>This XMPP Extension Protocol is copyright (c) 1999 - 2014 by the XMPP Standards Foundation (XSF).</copyright>
    <permissions>Permission is hereby granted, free of charge, to any person obtaining a copy of this specification (the &quot;Specification&quot;), to make use of the Specification without restriction, including without limitation the rights to implement the Specification in a software program, deploy the Specification in a network service, and copy, modify, merge, publish, translate, distribute, sublicense, or sell copies of the Specification, and to permit persons to whom the Specification is furnished to do so, subject to the condition that the foregoing copyright notice and this permission notice shall be included in all copies or substantial portions of the Specification. Unless separate permission is granted, modified works that are redistributed shall not contain misleading information regarding the authors, title, number, or publisher of the Specification, and shall not claim endorsement of the modified works by the authors, any organization or project to which the authors belong, or the XMPP Standards Foundation.</permissions>
    <warranty>## NOTE WELL: This Specification is provided on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. In no event shall the XMPP Standards Foundation or the authors of this Specification be liable for any claim, damages, or other liability, whether in an action of contract, tort, or otherwise, arising from, out of, or in connection with the Specification or the implementation, deployment, or other use of the Specification. ##</warranty>
    <liability>In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall the XMPP Standards Foundation or any author of this Specification be liable for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising out of the use or inability to use the Specification (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if the XMPP Standards Foundation or such author has been advised of the possibility of such damages.</liability>
    <conformance>This XMPP Extension Protocol has been contributed in full conformance with the XSF's Intellectual Property Rights Policy (a copy of which may be found at &lt;<link url='http://www.xmpp.org/extensions/ipr-policy.shtml'>http://www.xmpp.org/extensions/ipr-policy.shtml</link>&gt; or obtained by writing to XSF, P.O. Box 1641, Denver, CO 80201 USA).</conformance>
  </legal>
  <number>xxxx</number>
  <status>ProtoXEP</status>
  <type>Informational</type><sig>Standards</sig>
  <approver>Council</approver>
  <dependencies>
    <spec>XMPP Core</spec>
    <spec>XEP-0050</spec>
  </dependencies>
  <supersedes/>
  <supersededby/>
  <shortname>NOT_YET_ASSIGNED</shortname>
  <author>
    <firstname>Teemu</firstname>
    <surname>Väisänen</surname>
    <email>Teemu.Vaisanen@vtt.fi</email>
    <jid>uolevi@gmail.com</jid>
  </author>
  <revision>
    <version>Draft of 0.0.3</version>
    <date>2014-03-19</date>
    <initials>tuv</initials>
    <remark>
		<p>
			Third draft. 
			Title and abstract modified, 
			typos corrected	and added, 
			details and another figure added to 
			examples. Kosti's birthday!
		</p>
	</remark>
  </revision>
  <revision>
    <version>0.0.2</version>
    <date>2014-02-04</date>
    <initials>tuv</initials>
    <remark>
		<p>
			Second draft. 
			Includes more information about used and required features 
			of core XMPP, 
			a simple sequence diagram describing an example use case, 
			and details about authentication factors. 
			Use case about authenticating with a random string was added. 
			Also Sanna's and Seppo's birthdays!
		</p>
	</remark>
  </revision>
  <revision>
    <version>0.0.1</version>
    <date>2013-12-19</date>
    <initials>tuv</initials>
    <remark><p>First draft.</p></remark>
  </revision>
</header>

<section1 topic='Introduction' anchor='intro'>
	<p>
		Two-factor authentication is used, e.g., in web services 
		such as online banking, social networks and email to offer
		additional level for security of authentication procedure.	
		
		There exists no XMPP extension protocol describing how to 
		transmit information related to additional authentication factors.
		
		Two-factor authentication requires the use of two of the three 
		authentication factors.
		
		These three factors are 
		a knowledge factor 
		 meaning something only the user knows (passwords, PINs), 
		a possession factor 
		 meaning something only the user has (smart cards, phones, tokens), and 
		a inherence factor 
		 meaning something only the user is (biometrics).
	</p>
	<p>
		Entities in this document are 
		two XMPP client applications (of Verifier and Prover),
		two XMPP account (Verifier and Prover), 
		XMPP server(s) of these two accounts,
		and users of these two accounts.
	</p>
	<p>
		Verifier's XMPP account logins from Verifier XMPP client,
		automatically using existing credentials.
		
		A human user logins using his/her credentials from 
		the Prover client.
		
		The Verifier XMPP client authenticates (the user of) the Prover 
		by checking if the Prover is able to transmit a shared secret 
		to the Verifier, using described ad-hoc commands.
	</p>
	<p>
		This document describes authentication mechanisms which can be
		used for checking, e.g., 
		<ul>
		<li>if used Prover's XMPP account exists,</li>
		<li>if user of Prover's XMPP account knows or have required 
		credentials to login to this account,</li>
		<li>if the Prover and the Verifier XMPP accounts login from certain XMPP clients,</li>
		<li>if the Prover's XMPP client knows full JID of the Verifier account in a certain XMPP client, and</li>
		<li>if user of the Prover XMPP client, the Prover XMPP client, or some other
			entity is able to access to a shared secret and provide
			it using the Prover XMPP client during a wanted time window.</li>
		</ul>
		 
		 This shared secret MAY be transmitted and/or stored, e.g.,
		 <ul>
			<li>to a trusted platform module (TPM) of certain device,</li>
			<li>to certain smart card (such as SIM), or</li>
			<li>to a certain application in certain device.</li>
		</ul>
		
		In other words, the user the user or some other entity 
		participating to the authentication procedure MUST have or have 
		access something (where the secret is transmitted and/or stored).
		This means that the possession factor is present.
		
		At the moment, this document describes transmitting 
		a random string, 
		a Time-Based One-time Password (TOTP) or 
		a One-time pad 
		using XMPP's Ad-Hoc Commands, and using them for authentication.
	</p>
	<p>
		This document offers mechanisms to be used, e.g., in the 
		following scenarios:
	</p>
	<p>
	<ul>
		<li>
			Romeo rents a bike from a rental store.
			
			Access control of the bike is based on XMPP and an SMS, so	
			Romeo tells his XMPP account JID and phone number to a 
			merchant.
			
			Romeo installs store's bike application to his smart phone.

			The application enables 
			pairing of the smart phone with sensors connected to the bike, 
			unlocking bike's electric motor, and 
			publishing information from the bike to different services 
			 such as to rental store's web service.
			
			The merchant adds Romeo's account to the list of paid 
			customers for a fixed time and maps his phone number to
			certain bike application.
			
			Romeo starts the application, logins to his XMPP account, 
			gets a password in an SMS to his phone, enters it 
			to a form in the application, is authenticated and 
			authorized (during the fixed time) to start the motor in 
			the electric bike. 
			
			For the privacy reasons, the store does not publish location 
			of Romeo's account (in this scenario a Prover) but account 
			of their bike (a Verifier), and so all traffic from 
			the phone comes from the Verifier to their services.
			
			Romeo asks the merchant to add Julia's JID to be able to
			access location of the bike he rented.
			
			Rental store's security policies allow only their own 
			applications to access to their services. 

			<ul><li>
			In this scenario, Romeo's XMPP credentials can be thought 
			of as a knowledge factor.	
			
			SIM card is a possession factor, without
			it Romeo would not get the required password. Password 
			received to the SIM and inserted to the application, 
			again, is certainly a knowledge factor, because Romeo knows
			it. <!--Hmmm??.... difficult-->
			
			PIN which is used to open the SIM could be thought of as a 
			knowledge factor but it does not really relate to this 
			scenario.		
			
			The bike application can be thought of to be another
			possession factor. Romeo has to possess the 
			application	but does not have to know anything related to it.
			Verifier's credentials stored in the bike application are not 
			known by Romeo.
			</li></ul>
		</li>
		<li>
			Julia has installed rental stores' map application which 
			shows locations of certain bikes (XMPP accounts) in a map, 
			to her smart phone.
			
			She has received a Bluetooth dongle from the store to be used
			in the authentication procedure. She has paired it with her
			phone and bike application. Dongle has a button which has 
			to be pressed when someone logins from the application.

			Julia starts the application, logins to her XMPP account, 
			presses the flashing button in the dongle, is 
			authenticated, and authorized to access the location of the
			bike Romeo has rented.

			She hurries to Romeo's current location.
			
			<ul><li>
			In this scenario Julia's XMPP credentials can be thought of 
			as a knowledge factor.	
			
			The bike application is a possession factor, 
			because	Julia does have to know anything related to it, 
			just have and use it in her phone. 
			
			Dongle certainly is a possession factor without any 
			knowledge factors, because Julia just MUST have it and 
			press the button right after logging in. 
			
			Julia does not see or know a shared secret trasmitted 
			from the Verifier to the dongle and read from dongle by the 
			Prover.
			
			Verifier's credentials stored in the bike application are not 
			known by Julia.
			</li></ul>
		</li>
		<li>
			Romeo and Julia meet. 
			
			Julia gives her family's USB dongle that has a LED screen 
			and her smart phone to Romeo. 
			
			The smart phone has a pre-installed application 
			to lock/unlock doors in Julia's home.
			
			Romeo comes outside of Julia's home.
			
			Sadly, he hasn't asked Julia's XMPP account's credentials
			so he decides to login anonymously from the phone. 
			
			Romeo has luck, because house accepts anonymous logins, 
			because of possible alarm situations.
			
			USB dongle shows a password. 
			
			Romeo enters the password to a form of the application in
			the Julia's smart phone. 

			Anonymous XMPP account is correctly authenticated 
			(so it was correctly logged in from the correct application 
			in correct phone 
			and Romeo has access to the Julia's 
			family's USB dongle), 
			but sadly anonymous XMPP account is not authorized 
			to use the door unlocking mechanisms because there is no
			alarm present in the house.  

			So... Romeo cannot visit Julia secretly during 
			this night.
			
			<ul><li>
			Here Julia's XMPP credentials can be thought of as knowledge 
			factors.

			Dongle is a possession factor, but
			a password presented by the dongle, on the other hand, can be
			thought of as a knowledge factor.
			
			Bike application is a possession factor.
			Romeo does not have any knowledge related to it.
			</li></ul>
		</li>
	</ul>
	</p>
	<p>
		The Prover SHOULD be authenticated before the Verifier can 
		execute or ask executing any access control mechanism, e.g., to 
		check if the Prover's XMPP account is authorized use certain 
		resource(s). 
		The following factors have been used:
	</p>
	<ul>
		<li>
			The first factor is a knowledge factor. 
			Knowledge factors here could be 
			a shared secret known only by the Prover and Verifier, 
			knowing the correct and used authentication mechanisms,
			and a full JID of the Verifier. 
			A secret, or a password calculated from 
			the shared secret MUST be sent to only this full JID using 
			the	described ad-hoc commands.

			Notice that	Prover's XMPP account's username and password 
			are not necessarily used as knowledge factors, if, e.g., 
			mechanisms presented in &xep0175; are used.
		</li>
		<li>
			The second factor is a possession factor. This entity 
			COULD be, e.g., a device or application that the user has, 
			or an external device showing the secret or the password to 
			the user.
			
			The shared secret MUST be transmitted only
			to this certain entity, e.g., with SMS to certain mobile 
			phone number (SIM card), that the Prover is able to access.
		</li>
	</ul>
	<p>
		In addition to these, described mechanism offers possibility to 
		approve authentication inside only a certain time-slot.
	</p>
	<p>
		Prover and Verifier entities mean same as in &rfc6238; but are 
		implemented as two XMPP clients. When using terms of &xep0146;,
		Prover is Local Client and Verifier is Remote Client.
	</p>
	<p>
		Several mechanisms for client-to-client (C2C) authentication, such as 
		&xep0250; exist and at least one of them SHOULD be used with the 
		protocol defined in this document.
		Read more from <link url='#security'>Securityn</link> section.
	</p>
	<p>
		This document describes a new simple and extendable protocol 
		for transmitting information to be used in two-factor one-way 
		client authentication by specifying a profile on &xep0050;. 
		One-way here means that the actual user (e.g, a human) of 
		Prover's XMPP Client is not required to authenticate 
		the Verifier.
	</p>
	<section2 topic='Example: Prover has access to a shared secret' anchor='example-seq1'>
	<p>
		The following example presents a use case enabled by this XEP. 
		
	<example caption='Simplified example sequence of verifying that the 
	Prover has access to a shared secret' anchor='example1'><![CDATA[

    +-----------------+                  +-----------------+    
    |    Prover in    |<------(1.)------>|   XMPP server   |     
    |     domain Y    |                  |       in        |    
    |                 |<------(7.)------>|     domain Y    |    
    +-----------------+                  +-----------------+    
       |   ^   ^   ^                              ^             
       |   |   |   |                              |             
      (2.)(4.)(5.)(6.)                           (7.)           
       |   |   |   |                              |             
       V   |   |   |                              V             
    +-----------------+                  +-----------------+    
    | Verifier in     |<------(1.)------>|   XMPP server   |    
    |   domain X      |                  |       in        |    
    |(3.)(8.)(9.)(10.)|<------(7.)------>|     domain X    |    
    +-----------------+                  +-----------------+    


]]></example>
	</p>
	<p>
		<ol>
			<li anchor='e1-1'>The Prover and the Verifier login.</li>
			<li anchor='e1-2'>The Verifier discovers that the Prover wants 
			to authenticate, or access and use, e.g., certain resource, 
			device, or service. Full JID of	the Prover is now known by 
			the Verifier. Discovery mechanism is implementation 
			specific and out of scope of this document.</li>
			<li anchor='e1-3'>The Verifier selects an authentication
			mechanism to be used and generates a related secret, e.g.,
			a random string, a secret key and message for OTP, or a secret
			key for TOTP. The Verifier MAY implement one or more 
			authentication mechanisms presented in this document. 
			How the mechanisms are selected are implementation specific 
			and out of scope of this document.</li>
			<li anchor='e1-4'>The Verifier transmits information about 
			the used authentication mechanism through
			a secure channel to the Prover. 
			This secure channel is implementation specific and out of 
			scope of this document.</li>
			<li anchor='e1-5'>The Verifier transmits its own full JID 
			through a secure channel to the Prover. 
			This secure channel is implementation specific and out of 
			scope of this document.</li>
			<li anchor='e1-6'>The Verifier transmits the secret through 
			a secure channel to the Prover or to an entity 
			which Prover or user of the Prover has to be able to access. 
			This secure channel is implementation specific and out of 
			scope of this document.</li>
			<li anchor='e1-7'>The Prover and the Verifier communicate using 
			ad-hoc commands presented in this document, and the secret is 
			transmitted from Prover to the Verifier.
			</li>
			<li anchor='e1-8'>The Verifier checks the sender and content in 
			ad-hoc commands. If the secret is correct and the sender's 
			full JID is same as	Prover's full JID received in 
			<link url='#e1-2'>step (2.)</link>, the Verifier can be sure that 
			the Prover has access to the entity described in 
			<link url='#e1-5'>(step 5.)</link> and knows Verifier's full JID 
			transmitted in <link url='#e1-6'>(step 6.)</link>.</li>
			<li anchor='e1-9'>The Verifier MAY start executing
			internal or external access control procedures which are 
			shortly	discussed in <link url='#rules'>Business rules</link> 
			section. Various access control procedures MAY be executed 
			also during the authentication procedure to, e.g., enable 
			only certain JIDs to be able to authenticate.</li>
			<li anchor='e1-10'>Based on the access control rules,
			the user of the Prover client MAY be 
			authorized to access or start a wanted resource, service, 
			or device.
			</li>
		</ol>
	</p>
	<p>
		When talking about transmitting information to the Prover using 
		a secure channel, in practice, this information is transmitted 
		to an entity which is a device or an application the Prover is 
		using or executed in, or a device or application the 
		authenticated user or the Prover are able to access. 
		Examples of such devices and applications are 
		trusted platform modules (TPM) and SIM cards,
		smart phones, USB tokens or tokens with a display.  
		Example secure channels MAY be, e.g., SMS, writing and reading
		to/from TPM, and installing a correctly signed application able
		to calculate the current secret.
	</p>
	<p>
		Steps 4., 5., and 6. MAY be implemented to be executed simultaneously
		and using the same secure channel, but they MAY be executed also
		in different steps using different secure channels.
	</p>
	<p> 
		 Notice that it is possible that there is only one domain, so 
		 both Prover and Verifier would be, e.g., in domain X. 
	</p>	
	</section2>
	<section2 topic='Example: User has access to the 
	shared secret' anchor='example-seq2'>
	<p>
		The following sequence diagram presents the same use case as
		example 1 but a bit differently (XMPP servers are not presented
		in the figure and steps 1. and 6. have more details and step 10. 
		is presented as starting the wanted resource, service or device.
	</p>
 
	<example caption='Sequence diagram use case of verifying 
	that user has access to the shared secret' anchor='example2'><![CDATA[


  User            Prover         Verifier         Location      A resource, 
 (person)         client          client        of the secret    a service,
    |               |                |               |          or a device
    |     (1a.)    (1b.)            (1c.)            |              |
    |-------------->|      (2.)      |               |              |
    |               |--------------->|               |              |
    |               |               (3.)             |              |
    |               |   (4.)(5.)     |               |              |
    |               |<---------------|               |              |
    |               |                |      (6a.)    |              |
    |               |                |-------------->|              |
    |               |      (6b.)     |               |              |
    |<---------------------------------------------->|              |
    |     (6c.)     |                |               |              |
    |-------------->|      (7.)      |               |              |
    |               |<-------------->|               |              |
    |               |               (8.)             |              |
    |               |               (9.)             |              |
    |               |                |               |            (10.)
    
    
]]></example>
	<p>
		All other steps but 1. and 6. are the same as in 
		<link url='#example1'>example 1</link>.
	</p>
	<p>
	    <link url='#e1-1'>Step 1. of example 1.</link> is divided into 
	    three cases: 
	    In (1a.) the user inputs his/her XMPP account's credentials 
	    (such as JID and password) to the Prover client login screen, 
	    in (1b.) the Prover client logins and 
	    in (1c.) that the Verifier client logins.
	</p>
	<p>
	   <link url='#e1-6'>Step 6. of example 1.</link> is divided into 
	    three cases:
	    In (6a.) the shared secret is transmitted through a secure channel
	    to an external entity (e.g., with an SMS to a SIM card),
	    in (6b.) the user reads the secret from this external entity, and
	    in (6c.) the user inputs the secret to the Prover's to be used
	    in ad-hoc commands forms.
	</p>
	</section2>
</section1>

<section1 topic='Requirements' anchor='reqs'>
    <p>This document addresses the following requirements:</p>
    <ol>
        <li>Enable the Verifier entity to perform authentication of 
        their users (e.g., humans) by verifying that a Prover entity 
        holds a shared secret.</li>
		<li>Verifier's and Prover's XMPP accounts do not necessarily need
		to know each other before starting the authentication procedure
		nor be in rosters of each other.</li>
        <li>Re-use existing XMPP and Jabber protocols wherever possible.</li>
    </ol>
</section1>
    
    
<section1 topic='Discovery' anchor='disco'>
    <p>
		A client MAY advertise any authentication commands it 
		supports via &xep0030; (as described in <cite>XEP-0050</cite>).
    </p>
    <p>
		If these commands are advertised, &xep0115; can be used to 
		query capability of authentication commands in a client.
		If the Prover and the Verifier are working on a same physical 
		device, they both MAY know the exact format and existence of 
		supported commands.
    </p>
</section1>

<section1 topic='Glossary' anchor='glossary'>
  <p>
	  The following table lists common terms and corresponding 
	  descriptions.
  </p>
  <dl>
    <di><dt>HMAC</dt><dd>Keyed-Hashing for Message Authentication</dd></di>
  
    <di><dt>HMAC-SHA-256</dt><dd>HMAC-SHA-256 is the realization of the 
    HMAC message authentication code using the SHA-256 hash function.</dd></di>
  
    <di><dt>HMAC-SHA-512</dt><dd>HMAC-SHA-512 is the realization of the 
    HMAC message authentication code using the SHA-512 hash function.</dd></di>
  
    <di><dt>HOTP</dt><dd>HMAC-Based One-Time Password Algorithm</dd></di>
  
    <di><dt>Local Client</dt><dd>An XMPP client that wants to authenticate 
    itself to Remote Client.</dd></di>
   
    <di><dt>One-time pad</dt><dd>Example of perfectly secret encryption scheme.</dd></di>
  
    <di><dt>OTP</dt><dd>A one-time password is a password that is valid 
    for only one login session or transaction.</dd></di>
  
    <di><dt>Prover</dt><dd>Same as Local Client.</dd></di>
  
    <di><dt>Remote Client</dt><dd>An XMPP client that authenticates Local Client.</dd></di>
  
    <di><dt>SHA</dt><dd>US Secure Hash Algorithms</dd></di>
   
    <di><dt>Time-window</dt><dd>Lenght of time when the secret is valid.</dd></di>
   
    <di><dt>TOTP</dt><dd>Time-Based One-Time Password Algorithm</dd></di>
  
    <di><dt>Verifier</dt><dd>Same as Remote Client.</dd></di>
  </dl>
</section1>
<section1 topic='Use Cases' anchor='usecases'>
    <p>
		This document defines a profile of <cite>XEP-0050</cite> that 
		enables a client to perform the following tasks on a entity 
		that or which resources it wants to use:
	</p>
    <ol>
        <li>Authenticate with a random string</li>
        <li>Authenticate with a Time-Based One-Time Password (TOTP)</li>
        <li>Authenticate with a One-time pad</li>
        <li>Authenticate with...</li>
    </ol>
	<p>
		Although this document aims to define common use cases for 
		authentication,	an implementation or deployment MAY support any 
		subset and MAY support additional authentication mechanisms
		and ad-hoc commands not defined herein.
	</p>
    <p>
		<em>Note: The text that follows assumes that implementors have 
		read and understood <cite>XEP-0050</cite>, password 
		generation algorithms described in &rfc4226; and 
		<cite>RFC 6238</cite></em>,	and randomness requirements 
		described in &rfc4086;,	and know about one-time pads and perfect 
		secrecy.
	</p>

<!-- Random string -->

	<section2 topic='Authentication with a random string' anchor='set-random'>
        <p>
			Random string is a sequence of characters in random sequency.
			A random sequency is a sequence in which each successive 
			value is obtained merely by chance. None of the values is 
			dependent upon the preceding value in the sequence. &rfc4949;
		</p>
		<p>
			It is possible to enable random string to be valid only 
			during a certain time-window. 
		</p>
		<example caption='Local Client (Prover) requests to authenticate with a random string to a Remote Client (Verifier)'><![CDATA[
<iq from='juliet@example.com/prover'
    to='juliet@example.com/verifier'
    type='set'
    id='set-random-1'
    xml:lang='en'>
  <command xmlns='http://jabber.org/protocol/commands' 
           action='execute'
           node='http://jabber.org/protocol/auth#set-random'/>
</iq>
        ]]></example>
        <p>
			Unless an error occurs (see the 
			<link url='#errors'>Error Handling</link> section below), 
			the service SHOULD return the appropriate form.
		</p>
        
   
        <example caption='Remote Client (Verifier) replies with a form to set a random string'><![CDATA[
<iq from='juliet@example.com/verifier' 
    to='juliet@example.com/prover' 
    type='result' 
    id='set-random-1'
    xml:lang='en'>
  <command xmlns='http://jabber.org/protocol/commands'
           node='http://jabber.org/protocol/auth#set-random'
           sessionid='set-random:20140125T1022Z'
           status='executing'>
    <actions>
	  <complete />
    </actions>
    <x xmlns='jabber:x:data' type='form'>
      <title>Random string</title>
      <instructions>Send a random string</instructions>
      <field type='text-single'
             var='random'>
             label='RANDOM STRING'>
      </field>
    </x>
  </command>
</iq>
        ]]></example>
        <p>
			Prover receives the form and MAY or MAY NOT present it to 
			the user. If the form is presented, the user inputs the 
			random string to it. Otherwise the Prover client inserts the
			random string to the form automatically. 
        </p>
        <example caption='Local Client (Prover) submits the random string form to Remote Client (Verifier)'><![CDATA[
<iq from='juliet@example.com/prover'
    to='juliet@example.com/verifier'
    type='set'
    id='set-random-2'
    xml:lang='en'>
  <command xmlns='http://jabber.org/protocol/commands' 
           node='http://jabber.org/protocol/auth#set-random'
           sessionid='set-status:20140125T1022Z'>
    <x xmlns='jabber:x:data' type='submit'>
      <field var='random'>
        <value>f5sadvc23sadjc8j2dcamo1s</value>
      </field>
    </x>
  </command>
</iq>
        ]]></example>
        <p>
			After receiving a random string, the Verifier informs Prover 
			of completion.
		</p>
        <example caption='Remote Client (Verifier) informs Local Client (Prover) of completion'><![CDATA[
<iq from='juliet@example.com/verifier' 
    to='juliet@example.com/prover' 
    type='result' 
    id='set-random-2'
    xml:lang='en'>
  <command xmlns='http://jabber.org/protocol/commands'
           node='http://jabber.org/protocol/auth#set-random'
           sessionid='set-status:20140125T1022Z'
           status='completed'/>
</iq>
        ]]></example>
        </section2>
    
<!-- Time-Based One-Time Password (TOTP) -->
	
    <section2 topic='Authentication with a Time-Based One-Time Password (TOTP)' anchor='set-totp'>
        <p>
			Time-Based One-Time Password (TOTP) algorithm described in 
			<cite>RFC 6238</cite> is an extension of the HMAC-based 
			One-Time Password (HOTP) algorithm defined in 
			<cite>RFC 4226</cite>, to support the time-based moving 
			factor. In TOTP, time reference and a time step replaces 
			the counter in the HOTP computation.
		</p>
		<example caption='Local Client (Prover) requests to authenticate with a TOTP to a Remote Client (Verifier)'><![CDATA[
<iq from='juliet@example.com/prover'
    to='juliet@example.com/verifier'
    type='set'
    id='set-totp-1'
    xml:lang='en'>
  <command xmlns='http://jabber.org/protocol/commands' 
           action='execute'
           node='http://jabber.org/protocol/auth#set-totp'/>
</iq>
        ]]></example>
        <p>
			Unless an error occurs (see the 
			<link url='#errors'>Error Handling</link> section below), 
			the service SHOULD return the appropriate form.
		</p>
        
        <example caption='Remote Client (Verifier) replies with a form to set a TOTP'><![CDATA[
<iq from='juliet@example.com/verifier' 
    to='juliet@example.com/prover' 
    type='result' 
    id='set-totp-1'
    xml:lang='en'>
  <command xmlns='http://jabber.org/protocol/commands'
           node='http://jabber.org/protocol/auth#set-totp'
           sessionid='set-totp:20131020T1320Z'
           status='executing'>
    <actions>
	  <complete />
    </actions>
    <x xmlns='jabber:x:data' type='form'>
      <title>Time-Based One-Time Password</title>
      <instructions>Send a Time-Based One-Time Password</instructions>
      <field type='text-single'
             var='totp'>
             label='TOTP'>
      </field>
    </x>
  </command>
</iq>
        ]]></example>
        <p>
			Prover receives the form and MAY or MAY NOT present it to 
			the user.
        </p>
        <example caption='Local Client (Prover) submits the TOTP secret form to Remote Client (Verifier)'><![CDATA[
<iq from='juliet@example.com/prover'
    to='juliet@example.com/verifier'
    type='set'
    id='set-totp-2'
    xml:lang='en'>
  <command xmlns='http://jabber.org/protocol/commands' 
           node='http://jabber.org/protocol/auth#set-totp'
           sessionid='set-status:20131020T1320Z'>
    <x xmlns='jabber:x:data' type='submit'>
      <field var='totp'>
        <value>218418045</value>
      </field>
    </x>
  </command>
</iq>
        ]]></example>
        <p>
			After receiving a correct secret, the Verifier informs 
			Prover of completion.
		</p>
        <example caption='Remote Client (Verifier) informs Local Client (Prover) of completion'><![CDATA[
<iq from='juliet@example.com/verifier' 
    to='juliet@example.com/prover' 
    type='result' 
    id='set-totp-2'
    xml:lang='en'>
  <command xmlns='http://jabber.org/protocol/commands'
           node='http://jabber.org/protocol/auth#set-totp'
           sessionid='set-status:20131020T1320Z'
           status='completed'/>
</iq>
        ]]></example>
    </section2>
    
<!-- One-time pad -->
     
        <section2 topic='Authentication with a One-time pad' anchor='set-otpad'>
        <p>
			As described in <cite>RFC 4949</cite>, One-time pad is an encryption 
			algorithm in which the key is a random sequence of symbols 
			and each symbol is used for encryption only one time,
			i.e., used to encrypt only one plaintext symbol and thus 
			produce only one ciphertext symbol and thus produce only one 
			ciphertext symbol. A copy of the key is used similarly 
			for decryption. 
		</p>
		<p>
			Notice that if there is not any additional understandable 
			and confidential information to be encrypted between Prover 
			and	Verifier, there are no benefits of using One-time pad 
			instead of a <link url="#set-random">random string</link>.
		</p>
		<p>
			It is possible to enable One-time pad to be valid only 
			during a certain time-window. 
		</p>
		<example caption='Local Client (Prover) requests to authenticate with a One-time pad to a Remote Client (Verifier)'><![CDATA[
<iq from='juliet@example.com/prover'
    to='juliet@example.com/verifier'
    type='set'
    id='set-otpad-1'
    xml:lang='en'>
  <command xmlns='http://jabber.org/protocol/commands' 
           action='execute'
           node='http://jabber.org/protocol/auth#set-otpad'/>
</iq>
        ]]></example>
        <p>
			Unless an error occurs (see the 
			<link url='#errors'>Error Handling</link> section below), 
			the service SHOULD return the appropriate form.
		</p>
        
   
        <example caption='Remote Client (Verifier) replies with a form to set a One-time pad'><![CDATA[
<iq from='juliet@example.com/verifier' 
    to='juliet@example.com/prover' 
    type='result' 
    id='set-otpad-1'
    xml:lang='en'>
  <command xmlns='http://jabber.org/protocol/commands'
           node='http://jabber.org/protocol/auth#set-otpad'
           sessionid='set-totp:20131125T1022Z'
           status='executing'>
    <actions>
	  <complete />
    </actions>
    <x xmlns='jabber:x:data' type='form'>
      <title>One-time pad</title>
      <instructions>Send a One-time pad</instructions>
      <field type='text-single'
             var='otpad'>
             label='OTPAD'>
      </field>
    </x>
  </command>
</iq>
        ]]></example>
        <p>
			Prover receives the form and MAY or MAY NOT present it to 
			the user.
        </p>        
        <example caption='Local Client (Prover) submits the One-time pad form to Remote Client (Verifier)'><![CDATA[
<iq from='juliet@example.com/prover'
    to='juliet@example.com/verifier'
    type='set'
    id='set-otpad-2'
    xml:lang='en'>
  <command xmlns='http://jabber.org/protocol/commands' 
           node='http://jabber.org/protocol/auth#set-otpad'
           sessionid='set-status:20131125T1022Z'>
    <x xmlns='jabber:x:data' type='submit'>
      <field var='totp'>
        <value>2sc239dsac012jks92</value>
      </field>
    </x>
  </command>
</iq>
        ]]></example>
        <p>
			After receiving a One-time pad, the Verifier informs the 
			Prover of completion.
		</p>
        <example caption='Remote Client (Verifier) informs Local Client (Prover) of completion'><![CDATA[
<iq from='juliet@example.com/verifier' 
    to='juliet@example.com/prover' 
    type='result' 
    id='set-otpad-2'
    xml:lang='en'>
  <command xmlns='http://jabber.org/protocol/commands'
           node='http://jabber.org/protocol/auth#set-otpad'
           sessionid='set-status:20131125T1022Z'
           status='completed'/>
</iq>
        ]]></example>
        </section2>
    
</section1>


<section1 topic='Error Handling' anchor='errors'> 
    <p>
		Several error conditions are possible when a Prover sends a 
		command	request to the Verifier, as defined in the following 
		table. If one of these errors occurs, the Verifier entity MUST 
		return an error stanza to the requesting Prover.
	</p>

    <table caption='Error Conditions'>
        <tr>
            <th>Condition</th>
            <th>Cause</th>
        </tr>
        <!--<tr>
            <td>&conflict;</td>
            <td>The command cannot be completed because of a data or system
            conflict (e.g., ...)</td>
            </tr>-->
        <tr>
            <td>&feature;</td>
            <td>The specific command is not supported (even though the 
            ad-hoc commands protocol is).</td>
        </tr>
        <tr>
            <td>&forbidden;</td>
            <td>The requesting entity does not have sufficient 
            privileges to perform the command.</td>
        </tr>
        <tr>
            <td>&unavailable;</td>
            <td>The ad-hoc commands protocol is not supported.</td>
        </tr>
        <tr>
            <td>&payment;</td>
            <td>If the user needs to provide payment in order to access 
            to resources behind the Verifier (e.g., if the user is not 
            in the customer database or the customer's account is not 
            paid up).</td>
        </tr>        
    </table>
      
    <p>For the syntax of these errors, see &xep0086;. Naturally, other 
    errors MAY be returned as well.</p>
</section1>



<section1 topic='Implementation Notes' anchor='impl'>
	<p>
		Implementations of this protocol MAY introduce extra forms for 
		commands and MAY use other secret key generation mechanisms than 
		currently presented random string, TOTP and One-time pad. 
	</p>
	<p>
		There are several secure ways to transmit the random string, 
		One-time pads or the shared secret that is used in TOTP from 
		Verifier to the Prover. As described in 
		<link url='#example1'>example 1.</link>, descriptions of all
		secure channels are out of scope of this document. 
		As an example, if both Verifier and Prover entities are running 
		in one application inside one device, the shared secret can be 
		generated and transmitted inside running implementation and be 
		removed right after the usage, as also full JIDs.
	</p>
	<p>
		Some of the following mechanisms MAY be used to enable 
		random strings or One-time pad to be valid only during certain 
		time-window:
		<ul>
			<li>
				The Verifier generates and calculates a new random string
				or One-time pad directly after the time-window and 
				transmits the new One-time pad securely to the Verifier.
			</li>
			<li>
				The Verifier denies related ad-hoc commands coming 
				after the time-window, waits until the Verifier starts 
				authentication procedure again, generates a new 
				random string or One-time pad and transmits it securely 
				to the Verifier. Note that this approach takes less 
				resources than the first one. 
			</li>
		</ul>
	</p>
  </section1>
  
<!--<section1 topic='Accessibility Considerations' anchor='access'>
	<p>OPTIONAL.</p>
</section1>-->

<!--<section1 topic='Internationalization Considerations' anchor='i18n'>
	<p>OPTIONAL.</p>
</section1>-->

<section1 topic='Business Rules' anchor='rules'>
	<p>
		Presented authentication mechanism offers possibilities to 
		execute at least the following access policies and different
		combinations of them, but their detailed descriptions and how 
		policies are transmitted to the Verifier are out of scope of 
		this document:
	</p>
	<ul>
		<li>
			The policy MAY allow only anonymous XMPP accounts, only 
			non-anonymous XMPP accounts, or both, to be verified and/or 
			to access certain resources.
			
			No additional access control mechanisms are necessarily 
			needed. 
		</li>
		<li>
			The policy MAY allow, e.g., only JIDs in certain domains, 
			JIDs in a certain whitelist, JIDs in certain roster 
			group(s), or JIDs with certain subscription types to be 
			verified and/or to access certain resources. Additional 
			mechanisms are required, e.g., to check wanted roster.
		</li>
	</ul>
	<p>
		In each case, the Verifier MAY check Prover's JID right after 
		receiving an ad-hoc command or after a successful authentication 
		process. 
	</p>
	<p>
		If Prover's JID is not approved, the Verifier SHOULD 
		reply with &forbidden; error message.
	</p>
	<p>
		After the a successful verification the Verifier can, e.g.,
	</p>
	<ul>
		<li>start the wanted process,</li>
		<li>ask access rights from additional provision servers, 
		e.g. with &xep0324;, and/or</li>
		<li>give access to the wanted resource.</li>
	</ul>
	</section1>
<section1 topic='Security Considerations' anchor='security'>
	<p>
		If both the Prover and the Verifier are not	using the same 
		trusted XMPP server or are not using authenticated and encrypted
		client-to-server or server-to-server (S2S) connections, end-to-end
		C2C security MUST be established between the Prover and the Verifier,
		e.g., by using <cite>XEP-0250</cite>.
	</p>
	<p>
		In this protocol, the resourcepart of a JID is a required 
		identifier to uniquely identify a specific connection or object 
		belonging to the entity associated with an XMPP localpart at a 
		domain. Without a unique resourcepart, ad-hoc commands do not 
		necessarily go to correct entities.
	</p>
	<p>
		Mechanisms for determining when a command can be executed based 
		on permissions or rights are considered specific to the 
		application and/or implementation of <cite>XEP-0050</cite>, as
		defined in <cite>XEP-0050</cite>.
		
		In this application a command SHOULD be executed if and only 
		if it comes from full user's JID that is already known to 
		the Verifier. This decreases possibility to execute, e.g, 
		relay attacks.
		
		Determining other permissions or rights are considered specific
		to access policies of systems, as presented in 
		<link url='#rules'>Business Rules</link> section.
	</p>
	<p>
		Possibility of executing Denial-of-service (DoS) attacks against 
		the Verifier can be reduced by ending processing of received 
		messages coming from not authorized JIDs or containing incorrect
		secret as early as possible.
	</p>
	<p>
		Randomness requirements for security described in 
		<cite>RFC 4086</cite> apply.
	</p>
	<p>
		When using TOTP, security considerations of 
		<cite>RFC 6238</cite> apply.
	</p>
	<p>
		When using TOTP, HMAC-SHA-256 or HMAC-SHA-512 functions SHOULD 
		be used instead of the HMAC-SHA-1 that has been specified for 
		the HOTP computation in <cite>RFC 4226</cite>.
	</p>
	<p>
		When using TOTP, when an OTP is generated at the end of a 
		time-step window, the receiving time most likely falls into the 
		next time-step window. A validation system MUST set a policy 
		for an acceptable OTP transmission delay window for validation. 
		A larger acceptable delay window would expose a larger window 
		for attacks, so as in <cite>RFC 6238</cite>, we RECOMMEND that 
		at most one time step is allowed as the network delay.
	</p>
	<p>
		As described in <link url='#intro'>Introduction</link>, the 
		user of the Prover XMPP client does not necessarily know 
		anything about the Verifier. The Prover XMPP client will know 
		Verifiers full JID, but it is not necessarily told to the 
		human user. In addition to this, the user does not necessarily 
		know what the device or the application will do after a successful 
		authentication. Notice that this problem relates to every 
		closed source XMPP client implementations, thus implementations'
		code SHOULD be open source.
	</p>
	<p>
		When using One-time pads, to ensure one-time use, the copy of 
		the key used for encryption MUST be destroyed after use, as 
		is the copy used for decryption.
	</p>
	<p>
		When using random strings or One-time pads, commands containing 
		pads that have incorrect pad length, SHOULD not be executed.
	</p>

</section1>
<section1 topic='IANA Considerations' anchor='iana'>
	<p>
		This document requires no interaction with &IANA;.
	</p>
</section1>
<section1 topic='XMPP Registrar Considerations' anchor='registrar'>
    
    <section2 topic='Protocol Namespaces' anchor='registrar-protocol'>
        <p>The XMPP Registrar includes 'http://jabber.org/protocol/auth' 
        in its registry of protocol namespaces (see &NAMESPACES;).</p>
    </section2>

    <section2 topic='Field Standardization' anchor='registrar-formtype'>
        <p>&xep0068; defines a process for standardizing the fields used 
        within Data Forms scoped by a particular namespace 
        (see also &FORMTYPES;). The reserved fields for the 
        'http://jabber.org/protocol/auth' namespace are specified 
        below.</p>
        <code caption='Registry Submission'><![CDATA[
<form_type>
  <name>http://jabber.org/protocol/auth</name>
  <doc>XEP-XXXX</doc>
  <desc>Forms used for authenticating clients</desc>
  <field var='set-random'
         type='text-single'
         label='Random String'/>
  <field var='set-totp'
         type='text-single'
         label='Time-Based One-Time Password'/>
  <field var='set-otpad'
         type='text-single'
         label='One-Time Pad'/>
</form_type>
    ]]></code>
  </section2>
</section1>
<section1 topic='XML Schema' anchor='schema'>
	<p>
		Because the protocol defined here is a profile of 
		<cite>XEP-0050</cite>, no schema definition is needed.
	</p>
</section1>

<section1 topic='Acknowledgements' anchor='ack'>
	<p>
		Thanks to Kimmo Halunen, Sami Lehtonen, Jouni Hiltunen, 
		Dave Cridland, Kevin, Sergey Dobrov, and Elina for all 
		questions and valuable feedback.
	</p>
</section1>

</xep>
